<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computer Architecture: An Introduction</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        html {
            scroll-behavior: smooth;
        }
        body {
            font-family: 'Inter', sans-serif;
        }
        .prose {
            max-width: 80ch;
        }
        .prose h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
        }
        .prose h2, .section-title {
            font-size: 2.25rem;
            font-weight: 700;
            margin-top: 3rem;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 0.5rem;
        }
        .prose h3 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-top: 2rem;
            margin-bottom: 0.75rem;
        }
        .prose h4 {
            font-size: 1.25rem;
            font-weight: 600;
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
        }
        .prose p, .prose li {
            font-size: 1.125rem;
            line-height: 1.75;
        }
        .prose pre {
            background-color: #1f2937;
            color: #d1d5db;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
        }
        .prose code, .problem code {
            font-family: 'Courier New', Courier, monospace;
            background-color: #e5e7eb;
            padding: 0.2rem 0.4rem;
            border-radius: 0.25rem;
            font-size: 0.95em;
        }
        .prose pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        .prose a {
            color: #3b82f6;
            text-decoration: none;
            font-weight: 500;
        }
        .prose a:hover {
            text-decoration: underline;
        }
        .prose blockquote {
            border-left: 4px solid #6b7280;
            padding-left: 1rem;
            margin-left: 0;
            font-style: italic;
            color: #4b5563;
        }
        .prose table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1.5rem;
            font-size: 1rem;
        }
        .prose th, .prose td {
            border: 1px solid #d1d5db;
            padding: 0.75rem;
            text-align: left;
        }
        .prose th {
            background-color: #f3f4f6;
            font-weight: 600;
        }
        .question-card, .solution-card {
            background-color: white;
            border-radius: 0.5rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .question-number {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1d4ed8;
            margin-right: 1rem;
            flex-shrink: 0;
        }
        .question-text {
            font-size: 1.125rem;
            line-height: 1.75;
        }
        .solution-card h3 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1d4ed8;
            margin-bottom: 1rem;
        }
        .solution-card p {
            font-size: 1.1rem;
            line-height: 1.7;
            margin-bottom: 0.75rem;
        }
        .solution-card pre {
            background-color: #f3f4f6;
            color: #1f2937;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1rem;
        }
        nav a.active {
             color: #3b82f6;
             background-color: #eff6ff;
             font-weight: 600;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">
    <!-- Header and Navigation -->
    <header class="bg-white shadow-md sticky top-0 z-10">
        <nav class="container mx-auto px-6 py-4 flex justify-between items-center">
            <h1 class="text-2xl font-bold text-gray-900">Computer Architecture 101</h1>
            <div id="nav-links">
                <a href="#documentation" class="nav-link text-gray-700 hover:text-blue-600 px-4 py-2 rounded-lg">Documentation</a>
                <a href="#questions" class="nav-link text-gray-700 hover:text-blue-600 px-4 py-2 rounded-lg">Questions</a>
                <a href="#solutions" class="nav-link text-gray-700 hover:text-blue-600 px-4 py-2 rounded-lg">Solutions</a>
            </div>
        </nav>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto px-6 py-12">
        <!-- Documentation Section -->
        <section id="documentation">
            <article class="prose lg:prose-xl bg-white p-8 rounded-lg shadow-lg">
                <h1>Introduction to Computer Architecture</h1>
                <p>Welcome to this introductory guide on Computer Architecture. This document is designed for university students beginning their journey into the principles of programming and computer science. Understanding computer architecture is fundamental because it explains how the hardware you write software for actually works. It's the bridge between the physical world of electronics and the abstract world of code.</p>

                <!-- Section 1: History -->
                <h2>1. History of Computing Machines</h2>
                <p>The concept of automated computation is not new. It stretches back to antiquity with devices like the abacus. However, the modern computer's journey began with mechanical devices and evolved through electronics to the microscopic integrated circuits we use today.</p>
                <h3>The Mechanical Era</h3>
                <p>Early pioneers like Blaise Pascal (Pascaline, 1642) and Gottfried Wilhelm Leibniz (Stepped Reckoner, 1672) created mechanical calculators that could perform basic arithmetic. However, it was Charles Babbage who envisioned a programmable machine. He is often considered the "father of the computer" for his designs of the <strong>Difference Engine</strong> and the more ambitious <strong>Analytical Engine</strong> in the 19th century. The Analytical Engine was a mechanical general-purpose computer that possessed many features of modern computers, including an Arithmetic Logic Unit (ALU), control flow in the form of conditional branching and loops, and integrated memory. Working with him, <strong>Ada Lovelace</strong> is credited with writing the first algorithm intended to be processed by such a machine, making her the first computer programmer.</p>
                
                <h3>The Electronic Revolution</h3>
                <p>The 20th century saw the transition from mechanical to electronic computing. Key milestones include:</p>
                <ul>
                    <li><strong>ENIAC (Electronic Numerical Integrator and Computer):</strong> Completed in 1945, it was among the first general-purpose electronic computers. It was massive, filling a large room, and had to be physically rewired to change its program.</li>
                    <li><strong>The Von Neumann Architecture:</strong> A pivotal moment came when John von Neumann proposed a computer architecture where both program instructions and data are stored in the same memory. This "stored-program computer" concept is the basis for nearly all modern computers. It consists of a Central Processing Unit (CPU), a memory unit, and input/output devices.</li>
                </ul>
                <h3>Hierarchy and Necessity</h3>
                <p>The development of computing machines has been driven by necessity: the need for faster calculations for military applications (e.g., artillery firing tables), scientific research, and eventually, business and consumer applications. This led to a hierarchy of advancements:</p>
                <ol>
                    <li><strong>Vacuum Tubes:</strong> Enabled the first electronic computers but were bulky, unreliable, and consumed immense power.</li>
                    <li><strong>Transistors:</strong> Invented in 1947, they replaced vacuum tubes. They were smaller, faster, more reliable, and consumed less power. This marked the "second generation" of computers.</li>
                    <li><strong>Integrated Circuits (ICs):</strong> In the 1960s, engineers found a way to place many transistors onto a single silicon chip. This miniaturization drastically reduced cost and size while increasing power, leading to the "third generation".</li>
                    <li><strong>Microprocessors:</strong> The 1970s saw the development of the microprocessor, an entire CPU on a single chip, which ushered in the era of personal computers (the "fourth generation").</li>
                </ol>
                
                <!-- Section 2: Software -->
                <h2>2. The Meaning of Computer Software</h2>
                <p>If hardware represents the physical components of a computer system, <strong>software</strong> is the set of instructions, data, or programs used to operate computers and execute specific tasks. It is the intangible part of the computer that tells the hardware what to do and how to do it.</p>
                <blockquote>"Hardware is the stage, software is the play."</blockquote>
                <p>Software is broadly divided into two categories:</p>
                <ul>
                    <li><strong>System Software:</strong> This software manages the computer hardware and provides a platform for application software to run. The most important piece of system software is the <strong>Operating System (OS)</strong>, like Windows, macOS, or Linux. Other examples include device drivers and utility software.</li>
                    <li><strong>Application Software:</strong> This is the software designed to perform specific tasks for the end-user. Examples include web browsers, word processors, games, and database applications. The code you write as a programmer is typically application software.</li>
                </ul>
                <p>The relationship is layered: your application software talks to the operating system, and the operating system talks to the hardware. This abstraction makes programming much easier, as you don't need to know the exact electronic details of the hardware you're running on.</p>

                <!-- Section 3: Number Systems -->
                <h2>3. Number Systems</h2>
                <p>Computers do not understand human language or even the decimal numbers we use daily. At their core, they operate on a binary system. Understanding different number systems and how to convert between them is crucial.</p>
                
                <h3>General Representation of a Number</h3>
                <p>Any number can be represented in a base (or radix) \(b\) system. The value of a number is given by the polynomial formula:
                \[ D = \sum_{i=-m}^{n-1} d_i \cdot b^i \]
                Where \(d_i\) is the digit at position \(i\), \(b\) is the base, \(n\) is the number of integer digits, and \(m\) is the number of fractional digits.</p>
                
                <h4>Proof of the Formula (by Example)</h4>
                <p>This formula is the definition of positional notation. Consider the decimal number 37.5. Here, \(b=10\), \(n=2\), \(m=1\). The digits are \(d_1=3, d_0=7, d_{-1}=5\).
                Expanding the sum:
                \[ D = (d_1 \cdot 10^1) + (d_0 \cdot 10^0) + (d_{-1} \cdot 10^{-1}) \]
                \[ D = (3 \cdot 10) + (7 \cdot 1) + (5 \cdot 0.1) = 30 + 7 + 0.5 = 37.5 \]
                This demonstrates that the formula is a generalized way of expressing how the position of a digit determines its value.</p>

                <h3>Conversion Algorithms</h3>
                <h4>Decimal Integer to Any Base \(b\)</h4>
                <p>The algorithm uses successive division. Let \(D\) be the decimal integer.
                \[ D = q_0 \cdot b + r_0 \]
                Where \(q_0\) is the quotient and \(r_0\) is the remainder (which will be the least significant digit, \(d_0\)).
                Next, we divide the quotient \(q_0\):
                \[ q_0 = q_1 \cdot b + r_1 \]
                Here, \(r_1\) is the next digit, \(d_1\). We continue this until the quotient becomes 0.
                
                <h4>Proof of the Algorithm</h4>
                <p>By substituting the expressions for the quotients back into the first equation:
                \[ D = (q_1 \cdot b + r_1) \cdot b + r_0 = q_1 \cdot b^2 + r_1 \cdot b + r_0 \]
                Substituting again, \(q_1 = q_2 \cdot b + r_2\):
                \[ D = (q_2 \cdot b + r_2) \cdot b^2 + r_1 \cdot b + r_0 = q_2 \cdot b^3 + r_2 \cdot b^2 + r_1 \cdot b + r_0 \]
                This continues until the last quotient is zero. The final form is:
                \[ D = r_k \cdot b^k + \dots + r_2 \cdot b^2 + r_1 \cdot b^1 + r_0 \cdot b^0 \]
                This is the polynomial representation of the number in base \(b\), where the digits \(d_i\) are the remainders \(r_i\). Since we find \(r_0\) first, the remainders must be read in reverse order.</p>

                <h4>Decimal Fraction to Any Base \(b\)</h4>
                <p>The algorithm uses successive multiplication. Let \(F\) be the decimal fraction. We want to find the digits \(d_{-1}, d_{-2}, \dots\) in the representation:
                \[ F = d_{-1}b^{-1} + d_{-2}b^{-2} + d_{-3}b^{-3} + \dots \]
                
                <h4>Proof of the Algorithm</h4>
                <p>Multiply the entire equation by \(b\):
                \[ F \cdot b = d_{-1} + d_{-2}b^{-1} + d_{-3}b^{-2} + \dots \]
                The integer part of this result is \(d_{-1}\), the first fractional digit. The new fractional part is \(F_1 = d_{-2}b^{-1} + d_{-3}b^{-2} + \dots\).
                We repeat the process:
                \[ F_1 \cdot b = d_{-2} + d_{-3}b^{-1} + \dots \]
                The integer part is now \(d_{-2}\). This process is repeated to find successive digits until the fractional part becomes zero or the desired precision is reached.</p>
                
                <!-- Section 5: Memory -->
                <h2>5. Memory</h2>
                <p>Computer memory is any physical device capable of storing information temporarily or permanently. In the context of the Von Neumann architecture, memory holds both program instructions and data. Modern systems use a <strong>memory hierarchy</strong> to balance speed, cost, and capacity.</p>
                
                <p>The hierarchy is effective due to the <strong>Principle of Locality</strong>:</p>
                 <ul>
                    <li><strong>Temporal Locality:</strong> If an item is accessed, it is likely to be accessed again soon (e.g., loops in code).</li>
                    <li><strong>Spatial Locality:</strong> If an item is accessed, items with nearby memory addresses are likely to be accessed soon (e.g., sequential array elements).</li>
                </ul>
                <p>This principle allows a small, fast cache to significantly speed up access to a large, slow main memory.</p>
                <table>
                    <thead>
                        <tr><th>Level</th><th>Typical Size</th><th>Access Time</th><th>Managed By</th></tr>
                    </thead>
                    <tbody>
                        <tr><td>CPU Registers</td><td>~1 KB</td><td>&lt; 1 ns</td><td>Compiler</td></tr>
                        <tr><td>L1/L2 Cache</td><td>~16 KB - 4 MB</td><td>~1-10 ns</td><td>Hardware</td></tr>
                        <tr><td>L3 Cache</td><td>~8 MB - 64 MB</td><td>~10-30 ns</td><td>Hardware</td></tr>
                        <tr><td>Main Memory (RAM)</td><td>~4 GB - 64 GB</td><td>~50-100 ns</td><td>Operating System</td></tr>
                        <tr><td>Secondary Storage (SSD)</td><td>~256 GB - 4 TB</td><td>~50-150 Âµs</td><td>OS / User</td></tr>
                    </tbody>
                </table>

                <!-- Section 6: Data Representation -->
                <h2>6. Representation of Integers</h2>
                <h3>Unsigned Integers</h3>
                <p>A number is represented by its straightforward binary equivalent. With \(n\) bits, you can represent integers in the range \([0, 2^n - 1]\).</p>
                <h3>Signed Integers: Two's Complement</h3>
                <p>The most common method is <strong>Two's Complement</strong>. The most significant bit (MSB) is the <strong>sign bit</strong> (0 for positive, 1 for negative). With \(n\) bits, the range is \([-2^{n-1}, 2^{n-1} - 1]\).</p>
                
                <h4>Proof of the Range</h4>
                <ul>
                    <li><strong>Maximum Value:</strong> The largest positive number has a sign bit of 0, followed by \(n-1\) ones: \(011\dots1\). This is a geometric series: \(2^{n-2} + 2^{n-3} + \dots + 2^1 + 2^0\). The sum of this series is \( \frac{2^{n-1}-1}{2-1} = 2^{n-1} - 1 \).</li>
                    <li><strong>Minimum Value:</strong> The most negative number is represented by \(100\dots0\). In two's complement, the weight of the MSB is negative. So, the value is \(-1 \cdot 2^{n-1} + 0 \cdot 2^{n-2} + \dots + 0 \cdot 2^0 = -2^{n-1}\).</li>
                    <li><strong>Value of -1:</strong> The representation for -1 is \(111\dots1\). The value is \(-2^{n-1} + (2^{n-2} + \dots + 2^0) = -2^{n-1} + (2^{n-1} - 1) = -1\). This confirms the system's consistency.</li>
                </ul>

                <h4>Mathematical Foundation and Proof of Negation</h4>
                <p>Two's complement works based on modular arithmetic. For an n-bit system, arithmetic is performed modulo \(2^n\). The two's complement of a positive number \(x\) is defined as \(TC(x) = 2^n - x\).</p>
                <p>The "invert and add one" shortcut is derived from this definition. The one's complement (inverting the bits) of \(x\) is equivalent to subtracting \(x\) from the largest \(n\)-bit unsigned number, which is \(2^n - 1\).
                \[ \text{One's Complement of } x = (2^n - 1) - x \]
                If we add 1 to the one's complement:
                \[ ((2^n - 1) - x) + 1 = 2^n - x = TC(x) \]
                This proves that the "invert and add one" algorithm correctly computes the two's complement of a number.</p>
                
                <h3>Sign Extension</h3>
                <p>To convert an \(n\)-bit two's complement number to an \(m\)-bit number where \(m > n\), you must copy the sign bit to fill the new, higher-order bits. For a positive number, you pad with 0s. For a negative number, you pad with 1s.</p>
                
                <h2>7. Representation of Decimal Numbers</h2>
                <h3>Floating-Point Numbers (IEEE 754 Standard)</h3>
                <p>This standard represents decimal numbers in a form of scientific notation. The value is:
                \[ \text{Value} = (-1)^S \times (1.M) \times 2^{(E - \text{Bias})} \]
                <p>The standard defines several formats. The two most common are:</p>
                <ul>
                    <li><strong>Single-Precision (32-bit):</strong> 1 sign bit (S), 8 exponent bits (E), 23 mantissa bits (M). Bias = 127.</li>
                    <li><strong>Double-Precision (64-bit):</strong> 1 sign bit (S), 11 exponent bits (E), 52 mantissa bits (M). Bias = 1023.</li>
                </ul>
                <h4>Special Values</h4>
                <p>The standard reserves certain exponent values to represent special numbers:</p>
                <table>
                    <thead>
                        <tr><th>Exponent (E)</th><th>Mantissa (M)</th><th>Represents</th></tr>
                    </thead>
                    <tbody>
                        <tr><td>All 0s</td><td>0</td><td>Zero (\(\pm 0\))</td></tr>
                        <tr><td>All 0s</td><td>Non-zero</td><td>Denormalized Number (very small)</td></tr>
                        <tr><td>1 to (Max-1)</td><td>Any</td><td>Normalized Number</td></tr>
                        <tr><td>All 1s</td><td>0</td><td>Infinity (\(\pm \infty\))</td></tr>
                        <tr><td>All 1s</td><td>Non-zero</td><td>Not a Number (NaN)</td></tr>
                    </tbody>
                </table>
                 <p>This allows for representing outcomes of invalid operations, like \(1/0\) (Infinity) or \(\sqrt{-1}\) (NaN).</p>
            </article>
        </section>

        <!-- Questions Section -->
        <section id="questions" class="py-12">
            <div class="max-w-4xl mx-auto">
                <h2 class="section-title text-center">Practice Questions</h2>
                
                <div class="question-card">
                    <div class="flex items-start"><span class="question-number">1.</span><p class="question-text">What was the key innovation of the Von Neumann architecture, and how did it differ from earlier computer designs like the ENIAC?</p></div>
                </div>
                <div class="question-card">
                    <div class="flex items-start"><span class="question-number">2.</span><p class="question-text">Explain the purpose of the memory hierarchy and the Principle of Locality that makes it effective.</p></div>
                </div>
                <div class="question-card problem">
                    <div class="flex items-start"><span class="question-number">3.</span><p class="question-text">Convert the decimal number <strong>188</strong> to its 8-bit binary representation.</p></div>
                </div>
                <div class="question-card problem">
                    <div class="flex items-start"><span class="question-number">4.</span><p class="question-text">Convert the binary number <code>1010101101</code> to both hexadecimal and decimal.</p></div>
                </div>
                <div class="question-card">
                    <div class="flex items-start"><span class="question-number">5.</span><p class="question-text">What is the primary advantage of using Two's Complement to represent signed integers in computer systems? Explain from a hardware perspective.</p></div>
                </div>
                <div class="question-card problem">
                    <div class="flex items-start"><span class="question-number">6.</span><p class="question-text">Find the 8-bit Two's Complement representation of the decimal number <strong>-85</strong>.</p></div>
                </div>
                <div class="question-card problem">
                    <div class="flex items-start"><span class="question-number">7.</span><p class="question-text">What decimal number is represented by the 8-bit Two's Complement binary number <code>11010110</code>?</p></div>
                </div>
                <div class="question-card">
                    <div class="flex items-start"><span class="question-number">8.</span><p class="question-text">Explain the difference between system software and application software. Provide two examples of each.</p></div>
                </div>
                <div class="question-card">
                    <div class="flex items-start"><span class="question-number">9.</span><p class="question-text">Why is hexadecimal representation often used by programmers to view memory contents instead of binary?</p></div>
                </div>
                <div class="question-card problem">
                    <div class="flex items-start"><span class="question-number">10.</span><p class="question-text">Convert the hexadecimal number <strong>4CF</strong> to binary and decimal.</p></div>
                </div>
                <div class="question-card problem">
                    <div class="flex items-start"><span class="question-number">11.</span><p class="question-text">An 8-bit memory location stores the value <code>11110000</code>. What is its decimal value if it is interpreted as (a) an unsigned integer, and (b) a Two's Complement signed integer?</p></div>
                </div>
                <div class="question-card">
                    <div class="flex items-start"><span class="question-number">12.</span><p class="question-text">What does it mean for a floating-point number to be "Not a Number" (NaN)? Provide an example of a mathematical operation that would result in NaN.</p></div>
                </div>
                <div class="question-card">
                    <div class="flex items-start"><span class="question-number">13.</span><p class="question-text">Describe the roles of transistors and integrated circuits in the evolution of modern computers.</p></div>
                </div>
                <div class="question-card problem">
                    <div class="flex items-start"><span class="question-number">14.</span><p class="question-text">Perform the following binary addition: <code>01101011 + 00110110</code>. Assume the numbers are 8-bit unsigned integers.</p></div>
                </div>
                <div class="question-card problem">
                    <div class="flex items-start"><span class="question-number">15.</span><p class="question-text">Using 8-bit Two's Complement arithmetic, calculate <strong>45 - 20</strong> by converting the numbers to binary and adding them (i.e., calculate 45 + (-20)).</p></div>
                </div>
                 <div class="question-card problem">
                    <div class="flex items-start"><span class="question-number">16.</span><p class="question-text">A 4-bit system represents the number -3 as <code>1101</code> in two's complement. How would this number be represented in an 8-bit system using sign extension?</p></div>
                </div>
            </div>
        </section>

        <!-- Solutions Section -->
        <section id="solutions" class="py-12 bg-gray-100 rounded-lg">
            <div class="max-w-4xl mx-auto">
                <h2 class="section-title text-center">Solutions & Explanations</h2>

                <div class="solution-card"><h3>1. The Von Neumann Architecture</h3><p>The key innovation of the Von Neumann architecture was the <strong>stored-program concept</strong>. This meant that both the program instructions (the code) and the data the program operates on are stored in the same memory unit. In earlier designs like the ENIAC, the "program" was physically wired into the machine. To change the program, technicians had to manually unplug and replug cables, a process that could take days. The stored-program concept made computers far more flexible and powerful, as programs could be loaded, modified, and executed from memory just like data.</p></div>
                <div class="solution-card"><h3>2. The Memory Hierarchy & Locality</h3><p>The memory hierarchy exists to create a balance between speed, cost, and capacity. The <strong>Principle of Locality</strong> makes it work. It has two forms: <strong>Temporal Locality</strong> (if you use something, you'll likely use it again soon) and <strong>Spatial Locality</strong> (if you use something, you'll likely use data near it soon). Because of this predictable behavior, a small, fast, expensive cache can hold the data the CPU is most likely to need, making the large, slow, cheap main memory seem much faster than it is. This provides high performance at a reasonable cost.</p></div>
                <div class="solution-card"><h3>3. Convert 188 (Decimal) to Binary</h3><p>We use successive division by 2.</p><pre>188 / 2 = 94 remainder 0
94  / 2 = 47 remainder 0
47  / 2 = 23 remainder 1
23  / 2 = 11 remainder 1
11  / 2 = 5  remainder 1
5   / 2 = 2  remainder 1
2   / 2 = 1  remainder 0
1   / 2 = 0  remainder 1</pre><p>Reading the remainders from bottom to top, the result is <strong>10111100</strong>.</p></div>
                <div class="solution-card"><h3>4. Convert 1010101101 (Binary)</h3><p><strong>To Hexadecimal:</strong> Group into sets of four from the right.</p><pre>Binary: 0010 1010 1101
  0010 = 2
  1010 = A
  1101 = D</pre><p>The hexadecimal representation is <strong>2AD</strong>.</p><p><strong>To Decimal:</strong> Sum the powers of 2 for each '1' bit.</p><pre>  1 * 2^9 = 512
+ 1 * 2^7 = 128
+ 1 * 2^5 = 32
+ 1 * 2^3 = 8
+ 1 * 2^2 = 4
+ 1 * 2^0 = 1
----------------
Total = 685</pre><p>The decimal representation is <strong>685</strong>.</p></div>
                <div class="solution-card"><h3>5. Advantage of Two's Complement</h3><p>The primary advantage of Two's Complement is that it simplifies hardware logic. With this system, the CPU's Arithmetic Logic Unit (ALU) does not need separate circuitry for subtraction. Subtraction can be performed using the exact same addition circuits. For example, calculating <code>A - B</code> is equivalent to calculating <code>A + (-B)</code>. The ALU simply finds the two's complement of B and adds it to A. This reduces the complexity and cost of the hardware.</p></div>
                <div class="solution-card"><h3>6. Find 8-bit Two's Complement of -85</h3><p>First, find the binary representation of positive 85.</p><pre>85 decimal = 01010101 binary (in 8 bits)

1. Invert the bits:
   10101010

2. Add 1:
   10101010
+         1
-----------
   10101011</pre><p>The 8-bit Two's Complement of -85 is <strong>10101011</strong>.</p></div>
                <div class="solution-card"><h3>7. Convert 11010110 (Two's Complement) to Decimal</h3><p>The most significant bit is 1, so the number is negative. To find its magnitude, we take the two's complement of the number itself.</p><pre>Binary: 11010110

1. Invert the bits:
   00101001

2. Add 1:
   00101010</pre><p>Now, we convert this positive binary result to decimal: \(32 + 8 + 2 = 42\). Since the original number was negative, the final answer is <strong>-42</strong>.</p></div>
                <div class="solution-card"><h3>8. System vs. Application Software</h3><p><strong>System Software</strong> manages the computer's hardware and provides essential services. It acts as an intermediary between the hardware and the application software. Examples: <br>- Operating Systems (Windows, Linux) <br>- Device Drivers (e.g., for a printer or graphics card)</p><p><strong>Application Software</strong> is designed to perform specific tasks for the user. It runs "on top of" the system software. Examples: <br>- Web Browsers (Chrome, Firefox) <br>- Word Processors (Microsoft Word, Google Docs)</p></div>
                <div class="solution-card"><h3>9. Why Use Hexadecimal?</h3><p>Hexadecimal is used as a human-friendly shorthand for binary. Binary numbers can become very long and difficult to read, making it easy to make mistakes. Since one hexadecimal digit perfectly corresponds to a group of four binary digits (a nibble), it's very easy and efficient to convert between the two. This makes hexadecimal a compact and less error-prone way for programmers to read and write low-level data like memory addresses or raw file contents.</p></div>
                <div class="solution-card"><h3>10. Convert 4CF (Hexadecimal)</h3><p><strong>To Binary:</strong> Convert each hex digit to its 4-bit binary equivalent.</p><pre>4 = 0100
C = 1100
F = 1111</pre><p>The binary representation is <strong>010011001111</strong> (or 10011001111).</p><p><strong>To Decimal:</strong> Sum the powers of 16.</p><pre>  (4 * 16^2) + (12 * 16^1) + (15 * 16^0)
= (4 * 256) + 192 + 15
= 1024 + 192 + 15 = 1231</pre><p>The decimal representation is <strong>1231</strong>.</p></div>
                <div class="solution-card"><h3>11. Interpret 11110000</h3><p><strong>(a) As an unsigned integer:</strong></p><pre>128 + 64 + 32 + 16 + 0 + 0 + 0 + 0 = 240</pre><p>The value is <strong>240</strong>.</p><p><strong>(b) As a Two's Complement signed integer:</strong></p><p>The leading bit is 1, so it's negative. Find its magnitude:</p><pre>Original: 11110000
Invert:   00001111
Add 1:    00010000</pre><p><code>00010000</code> in binary is 16 in decimal. Since the original was negative, the value is <strong>-16</strong>.</p></div>
                <div class="solution-card"><h3>12. IEEE 754 "Not a Number" (NaN)</h3><p>NaN stands for "Not a Number" and is a special value in the IEEE 754 standard used to represent the result of an undefined or unrepresentable mathematical operation. For example, calculating the square root of a negative number (\(\sqrt{-1}\)) or dividing zero by zero (\(0/0\)) would produce NaN. It helps prevent a program from crashing by providing a specific value for these invalid outcomes.</p></div>
                <div class="solution-card"><h3>13. Role of Transistors and ICs</h3><p><strong>Transistors</strong> were the replacement for bulky, power-hungry, and unreliable vacuum tubes. They function as electronic switches and are the fundamental building blocks of all modern digital electronics. Their invention made computers smaller, faster, more reliable, and more energy-efficient, marking the second generation of computing.</p><p><strong>Integrated Circuits (ICs)</strong> were the next major leap. An IC places hundreds, thousands, or now billions of transistors onto a single tiny silicon chip. This massive miniaturization allowed for the creation of a microprocessor (an entire CPU on one chip), which in turn led to the personal computer revolution. ICs drastically reduced the cost and size of electronics while exponentially increasing their power and complexity.</p></div>
                <div class="solution-card"><h3>14. Binary Addition</h3><pre>  11  111  <- Carries
  01101011  (107 in decimal)
+ 00110110  (54 in decimal)
-----------
  10100001  (161 in decimal)</pre><p>The result is <strong>10100001</strong>.</p></div>
                <div class="solution-card"><h3>15. Two's Complement Subtraction (45 - 20)</h3><p>We calculate 45 + (-20).</p><p><strong>Step 1: Convert 45 to 8-bit binary.</strong></p><pre>45 = 32 + 8 + 4 + 1 = 00101101</pre><p><strong>Step 2: Find the 8-bit Two's Complement of -20.</strong></p><pre>Positive 20 = 16 + 4 = 00010100
Invert:                11101011
Add 1:                 11101100  (This is -20)</pre><p><strong>Step 3: Add the two binary numbers.</strong></p><pre>  1111  1   <- Carries
   00101101  (45)
+  11101100  (-20)
-----------
(1)00011001</pre><p>We discard the final carry bit that goes beyond the 8th position. The result is <strong>00011001</strong>.</p><p>Converting this back to decimal: 16 + 8 + 1 = <strong>25</strong>. This is the correct answer.</p></div>
                <div class="solution-card"><h3>16. Sign Extension</h3><p>To extend an \(n\)-bit two's complement number to an \(m\)-bit number (\(m > n\)), you must copy the sign bit into all the new bit positions to the left.</p><p>The number is <code>1101</code>. The sign bit (the MSB) is 1. To extend it from 4 bits to 8 bits, we add four bits to the left and fill them with the sign bit.</p><pre>
Original (4-bit): 1101
Sign bit is 1.
Extended (8-bit): 11111101
</pre><p>The 8-bit representation is <strong>11111101</strong>.</p></div>
            </div>
        </section>
    </main>

    <!-- Footer -->
    <footer class="bg-gray-800 text-white mt-12 py-6">
        <div class="container mx-auto text-center">
            <p>&copy; George Meshveliani, CST Department. All rights reserved.</p>
        </div>
    </footer>

    <script>
        // Script to handle active navigation link highlighting on scroll
        const sections = document.querySelectorAll('section');
        const navLinks = document.querySelectorAll('.nav-link');

        const options = {
            root: null, // it is the viewport
            threshold: 0.3,
            rootMargin: "-100px 0px -50% 0px"
        };

        const observer = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if(entry.isIntersecting) {
                    navLinks.forEach(link => {
                        link.classList.remove('active');
                        if(link.getAttribute('href').substring(1) === entry.target.id) {
                            link.classList.add('active');
                        }
                    });
                }
            });
        }, options);

        sections.forEach(section => {
            observer.observe(section);
        });

        // Set initial active link
        document.querySelector('a[href="#documentation"]').classList.add('active');
    </script>
</body>
</html>
